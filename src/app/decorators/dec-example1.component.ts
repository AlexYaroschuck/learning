import {Component} from '@angular/core';


/***
 * declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;

 * declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
 *
 * declare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>)
 * => TypedPropertyDescriptor<T>;

 * declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;
 */

@Component({
  selector: 'dec-example1',
  template: `hello, i'm decorator example, see into the console<br>
  ****
  <button (click)="test(2)">Log</button>
  <button (click)="testConst(2,3)">Property</button>
  <button (click)="paramsLogMethod('test')">Param</button>`,
})
@log
@logClassWithParams(...['params', 'other params'])
export class DecExample1Component {

  @log
  public name: string;

  public surname: string;

  testConst(name: string, surname: string) {
    this.name = name;
    this.surname = surname;

    const t = this.name;
  }

  @log
  test(n: number) {
    return n * 2;
  }

  paramsLogMethod(@log param: string) {
    console.log('paramsLogMethod has been executed');
  }
}

// method decorator
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
 */
function logMethod(target: any, key: string, descriptor: any) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const a = args.map(a => JSON.stringify(a)).join(';');
    const result = originalMethod.apply(this, args);
    const r = JSON.stringify(result);
    console.log(`Call: ${key}(${a}) => ${r}`);
    return result;

  };

  return descriptor;
}

/** This will be generated by TS for method
 * var C = (function () {
    function C() {
    }
    C.prototype.foo = function (n) {
        return n * 2;
    };
    //read for defineProperty here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
    Object.defineProperty(C.prototype, "foo",//Magic is here
        __decorate([
            log
        ], C.prototype, "foo", Object.getOwnPropertyDescriptor(C.prototype, "foo")));
    return C;
  })();


 var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) { // ensure that if it generated more than once it will not be override again
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;

    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;

    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
 */

// property decorator
function logProperty(target: any, key: string) {
  let _val = target[key]; // property value

  const getter = function () {
    console.log(`logProperty -> Get: ${key} => ${_val}`);
    return _val;
  };

  const setter = function (newVal) {
    console.log(`logProperty -> Set: ${key} => ${newVal}`);
    _val = newVal;
  };

  // Delete property.
  if (delete target[key]) {
    // Create new property with getter and setter
    Object.defineProperty(target, key, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  }
}

function logClass(target: any) {
  const originalConstructor = target;

  // function construct(constructor, args) {
  //   const c: any = function () {
  //     return constructor.apply(this, args);
  //   };
  //
  //   c.prototype = constructor.prototype;
  //
  //   return new c();
  // }

  const f: any = function (...args) {
    console.log(`logClass -> constructorName: ${originalConstructor.name}`);
  };

  f.prototype = originalConstructor.prototype;

  return f;
}

/*** target is Class
 * propertyKey -> method name
 * parameterIndex -> parameterIndex )))
 * call on creating, not on calling method
 *
 * !Important!!
 * A parameter decorator is not supposed to modify the behavior of a constructor, method or property.
 * A parameter decorator should only be used to generate some sort of metadata.
 */
function logParameter(target: any, methodName: string, parameterIndex: number) {
  console.log(`logParameter -> target:`);
  console.dir(target);
  console.log(`logParameter -> propertyKey: '${methodName}'`);
  console.log(`logParameter -> parameterIndex: ${parameterIndex}`);

  const metadataKey = `my_new_property`;

  if (Array.isArray(target[metadataKey])) {
    target[metadataKey].push('it\'s just created property on method ');
  } else {
    target[metadataKey] = 'it\'s just created property on class ';
  }

  console.log(`logParameter -> target:`);
  console.dir(target);
}

/**
 * Decorator factory
 */

function log(...args: any[]) {
  args = args.filter(x => x !== undefined);

  switch (args.length) {
    case 1:
      return logClass.apply(this, args); // apply -> call the method with params
    case 2:
      return logProperty.apply(this, args);
    case 3:
      if (typeof args[2] === 'number') {
        return logParameter.apply(this, args);
      }
      return logMethod.apply(this, args);
    default:
      throw new Error('Decorators are not valid here!');
  }
}

function logClassWithParams(...params) {
  return (target: any) => {
    console.log('logClassWithParams');
    console.dir(params);
  };
}
